#' Process tracing estimator
#'
#' Draw conclusions from a model given a query, data, and process tracing strategies
#'
#' See https://book.declaredesign.org/observational-causal.html#process-tracing
#'
#' @param causal_model a model generated by `CausalQueries`
#' @param data a single row dataset with data on nodes in the model
#' @param query a causal query of interest
#' @param strategies a list of sets of nodes examined
#'
#' @return a data.frame of estimates
#'
#' @export
#'
process_tracing_estimator <- function(causal_model, query, data, strategies) {

  if(!requireNamespace("CausalQueries")){
    message("The process_tracing_estimator function requires the 'CausalQueries' package.")
    return(invisible())
  }

  causal_model %>%
    CausalQueries::query_model(query = query,
                               given = CausalQueries::strategy_statements(data, strategies)) %>%
    select(estimate = mean) %>%
    mutate(XY = paste0("X", data$X, "Y", data$Y),
           term = strategies %>% lapply(paste, collapse = "-") %>% unlist)

}

#' Generate lags in grouped data
#'
#' See https://book.declaredesign.org/observational-causal.html#difference-in-differences
#'
#' @param x Vector of values
#' @param groups Grouping variable
#' @param n Positive integer of length 1, giving the number of positions to lead or lag by
#' @param order_by Ordering variable withing group (e.g., time)
#' @param default Value used for non-existent rows. Defaults to NA.
#'
#' @return vector of lagged values
#'
#' @export
#'
#' @importFrom tibble tibble
#' @importFrom rlang enexpr `:=` `!!`
#' @importFrom dplyr group_by mutate ungroup pull lag `%>%`
#'
#'
lag_by_group <- function(x, groups, n = 1, order_by, default = NA) {
  x_nm <- enexpr(x)
  grp_nm <- enexpr(groups)
  tibble(!!x_nm := x, !!grp_nm := groups, order_by___ = order_by) %>%
    group_by(!!grp_nm) %>%
    mutate(!!x_nm := lag(!!x_nm, n = n, default = default, order_by = order_by___)) %>%
    ungroup %>%
    pull(!!x_nm)
}

#' Tidy helper function for did_multiplegt
#'
#' Runs did_multiplegt estimation function and returns tidy data frame output
#'
#' See https://book.declaredesign.org/observational-causal.html#difference-in-differences
#'
#' @param data a data.frame
#' @param ... options passed to did_multiplegt
#'
#' @return a data.frame of estimates
#'
#' @export
#'
#' @importFrom tibble tibble
#'
did_multiplegt_tidy <- function(data, ...) {

  if(!requireNamespace("DIDmultiplegt")){
    message("The did_multiplegt_tidy function requires the 'DIDmultiplegt' package.")
    return(invisible())
  }

  fit <- DIDmultiplegt::did_multiplegt(df = data, ...)
  tibble(estimate = fit$effect)
}

#' Tidy helper function for rdrobust function
#'
#' Runs rdrobust estimation function and returns tidy data frame output
#'
#' See https://book.declaredesign.org/observational-causal.html#regression-discontinuity-designs
#'
#' @param data a data.frame
#' @param y is the dependent variable (rdrobust argument)
#' @param x is the running variable (a.k.a. score or forcing variable) (rdrobust argument)
#' @param c specifies the RD cutoff in x; default is c = 0 (rdrobust argument)
#' @param subset An optional bare (unquoted) expression specifying a subset of observations to be used
#' @param term Symbols or literal character vector of term that represent quantities of interest, i.e. Z. If FALSE, return the first non-intercept term; if TRUE return all term. To escape non-standard-evaluation use !!.
#'
#' @return a data.frame of estimates
#'
#' @importFrom rlang quo_is_null quo
#' @importFrom dplyr filter pull
#' @importFrom rlang quo_is_null quo enquo
#' @export
rdrobust_tidy <- function(data, y, x, c, subset = NULL, term = NULL){

  if(!requireNamespace("rdrobust")){
    message("The rdrobust_tidy function requires the 'rdrobust' package.")
    return(invisible())
  }

  if(!missing(subset))
    data <- filter(data, !!enquo(subset))
  fit <- try(rdrobust::rdrobust(y = pull(data, {{y}}), x = pull(data, {{x}}), c = c))
  if(!inherits(fit, "try-error")) {
    ret <- data.frame(rownames(fit$coef), fit$coef, fit$se, fit$z, fit$pv, fit$ci, c = fit$c)
    row.names(ret) <- NULL
    names(ret) <- c("term", "estimate", "std.error", "statistic", "p.value", "conf.low", "conf.high", "cutoff")
    if(!is.null(term))
      ret <- ret[ret$term == term, ]
  } else {
    ret <- data.frame(term = "Robust", estimate = NA, std.error = NA, statistic = NA, p.value = NA, conf.low = NA, conf.high = NA, cutoff = 0.5, error = as.character(fit))
  }
  ret
}

